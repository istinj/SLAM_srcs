#pragma once
#include "opencv2/opencv.hpp"
#include <Eigen/Core>
#include <Eigen/Geometry>
#include <Eigen/StdVector>
#include <map>
#include "posit_solver.h"
#include "g2o/core/sparse_optimizer.h"

#include "point_track.h"
#include "frame_info.h"
#include "key_frame.h"
#include "frame_match.h"
#include "landmark.h"

namespace rgbdt {

	/** class that manages the tracker while running, triggers loop closures and initiates the global optimization
	it keeps:
	- all frameinfos so far (the trajectory of the system)
	- all keyframes so far. these are generated by the FrameInfoManager  by analyzing the tracker status
	- all landmarks. (these are unused at the moment)
	- a copy of a g2o graph used for global optimization
	*/
	class FrameInfoManager
	{
		public:
		//! ctor, sets default parameters
		FrameInfoManager();
		//! dtor
		~FrameInfoManager();


		FrameInfoMap frames;    //< all frames seen so far (fed in by the tracker)
		KeyFrameMap keyframes;  //< all keyframes GENERATED so far
		LandmarkMap  landmarks; //< all landmarks GENERATED so far
		FrameMatchList matches; //< all relative transforms between keyframes

		/** only function of the FrameInfoManger. It is meant to be called after adding a frame to the tracker,
		as follows:

		tracker.addFrame(...)
		frame_info_manager.putFrame(new FrameInfo(tracker.currentFrameInfo()), tracker.currentGray(), tracker.currentDepth());

		What happens inside is:
		- the landmarks are generated, based on the frame_info passed as argument
		- when the finfo->keyframe_seq==finfo->seq a new keyframe is constructed and added to the 
		existing ketframes. Then the function manageKeyFrame is called.

		If a potential loop closure is found posit is run on the two frames
		Each good loop closure is passed to g2o and the graph is optimized

		@param finfo: the currentFrameInfo() of the tracker, <b>alloacated on the HEAP</b> as the manager will become its owner
		@param current_gray: the current gray image
		@param current_depth: the current depth image
		*/
		void putFrame(FrameInfo* finfo,
		const cv::Mat& current_gray = cv::Mat(), 
		const cv::Mat& current_depth = cv::Mat());

		//! returns the last frame in the pool
		FrameInfo* lastFrame();

		/** called by putFrame when a new keyframe is found
		This involves:
		- extracting  keypoints and features from the image passed as argument to form the new keyframe
		- matching of the current keyframe with all previous ones, based on the features found
		- a previous frame is said to match if it has a certain number of matches
		- each previous frame that match is verified through the tryMatch function that runs posit on the features
		- if posit is successfull a match is added to the pool of matches
		*/
		void manageKeyframe(KeyFrame* kframe);

		/**
		tries to match the two keyframes via posit. True on success
		@param result: the transform between parent and current
		@param current: the current keyframe
		@param parent: the previous keyframe to match
		@param matches: the feature matches
		*/
		bool tryMatch(Eigen::Isometry3f& result,
			const KeyFrame* current, 
			const KeyFrame* parent, 
			const std::list<cv::DMatch>& matches);

		//! initializes g2o. Convenience called in the ctor
		g2o::SparseOptimizer * g2oInit();

		//! reflects the state to g2o, runs an optimization, and copies back the result
		void optimize();

		cv::FeatureDetector* detector;
		cv::DescriptorExtractor* extractor;
		cv::DescriptorMatcher* matcher;

		std::vector<int> keyframe_seq_index; //< vector of progressive indices of keyframes, used for bookkeeping

		std::set<int> closures; //< sequence numbers of the candidate closing frames

		PositSolver solver;
		int solver_iterations;
		int closure_frame_window;
		int min_closure_matches;
		int min_closure_inliers;
		g2o::SparseOptimizer* optimizer;
	};

}// end namespace